use async_trait::async_trait;
use std::mem::transmute;
use async_nats::*;
use serde::{
    Serialize,
    Deserialize
};

use anyhow::{
    Result,
    Error
};

/// The main trait that creates RPC services.
///
/// # Example
///
/// ```ignore
/// struct Hello;
///
/// impl Servicer<(), String> for Hello {
///     fn topic(&self) -> String {
///         "hello".to_string()
///     }     
///
///     async fn handler(&self, _: ()) -> String {
///         String::new("World")
///     }
/// }
/// ```
#[async_trait]
pub trait Servicer<Q, S> {
    fn topic(&self) -> String;
    async fn handler(&self, message: Q) -> S;
}

/// The main trait that creates RPC caller.
///
/// # Example
///
/// ```ignore
/// struct Hello;
///
/// impl Caller<(), String> for Hello {
///     fn topic(&self) -> String {
///         "hello".to_string()
///     }     
///
///     async fn serializer(&self, _: ()) -> Vec<u8> {
///         Vec::new()
///     }
///
///     async fn deserializer(&self, data: &[u8]) -> Result<S> {
///         Ok(String::from_utf8(data).unwrap())
///     }
/// }
/// ```
pub trait Caller<Q, S> {
    fn topic(&self) -> String;
    fn serializer(&self, message: Q) -> Vec<u8>;
    fn deserializer(&self, data: &[u8]) -> Result<S>;
}

/// caller generated by rpc.
pub struct RpcCaller<Q, S> {
    topic: String,
    conn: Connection,
    caller: Box<dyn Caller<Q, S> + Send + Sync>
}

impl<Q, S> RpcCaller<Q, S> {
    pub fn new(
        topic: &str, 
        conn: Connection, 
        caller: Box<dyn Caller<Q, S> + Send + Sync>
    ) -> Self {
        Self {
            topic: topic.to_string(),
            caller,
            conn
        }
    }

    /// Call remote service.
    ///
    /// # Example
    ///
    /// ```ignore
    /// struct Hello;
    ///
    /// impl Caller<(), String> for Hello {
    ///     fn topic(&self) -> String {
    ///         "hello".to_string()
    ///     }     
    ///
    ///     async fn serializer(&self, _: ()) -> Vec<u8> {
    ///         Vec::new()
    ///     }
    ///
    ///     async fn deserializer(&self, data: &[u8]) -> Result<S> {
    ///         Ok(String::from_utf8(data).unwrap())
    ///     }
    /// }
    ///
    /// let rpc = Rpc::new("nats://127.0.0.1:4222")
    ///     .await
    ///     .unwrap();
    /// let caller = rpc.caller(Hello);
    /// // caller.call(());
    /// ```
    pub async fn call(&self, req: Q) -> Result<S> {
        let req_data = self.caller
            .serializer(req);
        let res = self.conn
            .request(&self.topic, req_data)
            .await?;
        let res_data = res
            .data
            .as_slice();
        self.caller
            .deserializer(res_data)
    }
}

#[derive(Debug)]
pub struct TlsOptions<'a> {
    pub cert: &'a str,
    pub key: &'a str,
}

#[derive(Debug)]
pub struct RpcOptions<'a> {
    pub server: &'a str,
    pub token: Option<&'a str>,
    pub tls: Option<TlsOptions<'a>>,
}

pub struct Rpc(
    Connection
);

impl Rpc {
    /// Create Rpc service.
    ///
    /// # Example
    ///
    /// ```ignore
    /// struct HelloService;
    ///
    /// impl Servicer<(), String> for HelloService {
    ///     fn topic(&self) -> String {
    ///         "hello".to_string()
    ///     }     
    ///
    ///     async fn handler(&self, _: ()) -> String {
    ///         String::new("World")
    ///     }
    /// }
    ///
    /// rpc.servicer(HelloService)
    ///     .unwrap();
    ///
    /// struct HelloClient;
    ///
    /// impl Caller<(), String> for HelloClient {
    ///     fn topic(&self) -> String {
    ///         "hello".to_string()
    ///     }     
    ///
    ///     async fn serializer(&self, _: ()) -> Vec<u8> {
    ///         Vec::new()
    ///     }
    ///
    ///     async fn deserializer(&self, data: &[u8]) -> Result<S> {
    ///         Ok(String::from_utf8(data).unwrap())
    ///     }
    /// }
    ///
    /// let rpc = Rpc::new("nats://127.0.0.1:4222")
    ///     .await
    ///     .unwrap();
    /// let caller = rpc.caller(HelloClient);
    /// // caller.call(());
    /// ```
    pub async fn new(options: RpcOptions<'_>) -> Result<Self> {
        let mut opt = options
            .token
            .map(|t| Options::with_token(t))
            .unwrap_or_else(|| Options::new());
        if let Some(tls) = options.tls {
            opt = opt
                .client_cert(tls.cert, tls.key)
                .tls_required(true);
        }

        let conn = opt
            .connect(options.server)
            .await?;
        Ok(Self(conn))
    }

    /// append service to rpc.
    ///
    /// # Example
    ///
    /// ```ignore
    /// struct Hello;
    ///
    /// impl Servicer<(), String> for Hello {
    ///     fn topic(&self) -> String {
    ///         "hello".to_string()
    ///     }     
    ///
    ///     async fn handler(&self, _: ()) -> String {
    ///         String::new("World")
    ///     }
    /// }
    ///
    /// let rpc = Rpc::new("nats://127.0.0.1:4222")
    ///     .await
    ///     .unwrap();
    /// rpc.servicer(Hello)
    ///     .unwrap();
    /// ```
    pub async fn servicer<Q, S, T>(&self, service: T) -> Result<&Self>
    where
        T: Servicer<Q, S> + Send + Sync + 'static,
        Q: Deserialize<'static> + Send + Sync,
        S: Serialize + Send + Sync,
    {
        let sub = self.0.subscribe(&service.topic()).await?;
        tokio::spawn(async move {
            while let Some(payload) = sub.next().await {
                let data = unsafe {
                    transmute(payload.data.as_slice())    
                };

                if let Ok(message) = serde_json::from_slice::<'static, Q>(data) {
                    let res = service.handler(message).await;
                    payload.respond(serde_json::to_vec(&res)?).await?;
                }
            }
    
            Ok::<(), Error>(())
        });

        Ok(self)
    }

    /// append service to rpc and return caller.
    ///
    /// # Example
    ///
    /// ```ignore
    /// struct Hello;
    ///
    /// impl Caller<(), String> for Hello {
    ///     fn topic(&self) -> String {
    ///         "hello".to_string()
    ///     }     
    ///
    ///     async fn serializer(&self, _: ()) -> Vec<u8> {
    ///         Vec::new()
    ///     }
    ///
    ///     async fn deserializer(&self, data: &[u8]) -> Result<S> {
    ///         Ok(String::from_utf8(data).unwrap())
    ///     }
    /// }
    ///
    /// let rpc = Rpc::new("nats://127.0.0.1:4222")
    ///     .await
    ///     .unwrap();
    /// let caller = rpc.caller(Hello);
    /// // caller.call(());
    /// ```
    pub fn caller<Q, S, T>(&self, caller: T) -> RpcCaller<Q, S>
    where T: Caller<Q, S> + Send + Sync + 'static
    {
        RpcCaller::new(
            &caller.topic(), 
            self.0.clone(), 
            Box::new(caller)
        )
    }
}
