use async_trait::async_trait;
use std::mem::transmute;
use async_nats::*;
use serde::{
    Serialize,
    Deserialize
};

use anyhow::{
    Result,
    Error
};

/// The main trait that creates RPC services.
///
/// #Example
///
/// ```no_run
/// struct Hello;
///
/// impl Servicer<(), String> for Hello {
///     async fn handler(&self, _: ()) -> String {
///         String::new("World")
///     }
/// }
/// ```
#[async_trait]
pub trait Servicer<Q, S> {
    fn topic(&self) -> String;
    async fn handler(&self, message: Q) -> S;
}

/// The main trait that creates RPC caller.
///
/// #Example
///
/// ```no_run
/// struct Hello;
///
/// impl Caller<(), String> for Hello {
///     async fn serializer(&self, _: ()) -> Vec<u8> {
///         Vec::new()
///     }
///
///     async fn deserializer(&self, data: &[u8]) -> Result<S> {
///         Ok(String::from_utf8(data).unwrap())
///     }
/// }
/// ```
pub trait Caller<Q, S> {
    fn topic(&self) -> String;
    fn serializer(&self, message: Q) -> Vec<u8>;
    fn deserializer(&self, data: &[u8]) -> Result<S>;
}

/// caller generated by rpc.
pub struct RpcCaller<Q, S> {
    topic: String,
    conn: Connection,
    caller: Box<dyn Caller<Q, S> + Send + Sync>
}

impl<Q, S> RpcCaller<Q, S> {
    pub fn new(
        topic: &str, 
        conn: Connection, 
        caller: Box<dyn Caller<Q, S> + Send + Sync>
    ) -> Self {
        Self {
            topic: topic.to_string(),
            caller,
            conn
        }
    }

    /// # Unit Test
    ///
    /// ```
    /// use bytes::BytesMut;
    /// use rtp::extensions::Extension;
    ///
    /// let buffer = [
    ///     0x22, 0xaa, 0x36, 0x3f
    /// ];
    /// 
    /// let mut writer = BytesMut::new();
    /// let extension = Extension {
    ///     data: &[0xaa, 0x36, 0x3f],
    ///     kind: 2,
    /// };
    /// 
    /// extension.into(&mut writer);
    /// assert_eq!(&writer[..], &buffer[..]);
    /// ```
    pub async fn call(&self, req: Q) -> Result<S> {
        let req_data = self.caller
            .serializer(req);
        let res = self.conn
            .request(&self.topic, req_data)
            .await?;
        let res_data = res
            .data
            .as_slice();
        self.caller
            .deserializer(res_data)
    }
}

pub struct Rpc(
    Connection
);

impl Rpc {
    /// # Unit Test
    ///
    /// ```
    /// use bytes::BytesMut;
    /// use rtp::extensions::Extension;
    ///
    /// let buffer = [
    ///     0x22, 0xaa, 0x36, 0x3f
    /// ];
    /// 
    /// let mut writer = BytesMut::new();
    /// let extension = Extension {
    ///     data: &[0xaa, 0x36, 0x3f],
    ///     kind: 2,
    /// };
    /// 
    /// extension.into(&mut writer);
    /// assert_eq!(&writer[..], &buffer[..]);
    /// ```
    pub async fn new(uri: &str) -> Result<Self> {
        Ok(Self(connect(uri).await?))
    }

    /// # Unit Test
    ///
    /// ```
    /// use bytes::BytesMut;
    /// use rtp::extensions::Extension;
    ///
    /// let buffer = [
    ///     0x22, 0xaa, 0x36, 0x3f
    /// ];
    /// 
    /// let mut writer = BytesMut::new();
    /// let extension = Extension {
    ///     data: &[0xaa, 0x36, 0x3f],
    ///     kind: 2,
    /// };
    /// 
    /// extension.into(&mut writer);
    /// assert_eq!(&writer[..], &buffer[..]);
    /// ```
    pub async fn servicer<Q, S, T>(&self, service: T) -> Result<&Self>
    where
        T: Servicer<Q, S> + Send + Sync + 'static,
        Q: Deserialize<'static> + Send + Sync,
        S: Serialize + Send + Sync,
    {
        let sub = self.0.subscribe(&service.topic()).await?;
        tokio::spawn(async move {
            while let Some(payload) = sub.next().await {
                let data = unsafe {
                    transmute(payload.data.as_slice())    
                };

                if let Ok(message) = serde_json::from_slice::<'static, Q>(data) {
                    let res = service.handler(message).await;
                    payload.respond(serde_json::to_vec(&res)?).await?;
                }
            }
    
            Ok::<(), Error>(())
        });

        Ok(self)
    }

    /// # Unit Test
    ///
    /// ```
    /// use bytes::BytesMut;
    /// use rtp::extensions::Extension;
    ///
    /// let buffer = [
    ///     0x22, 0xaa, 0x36, 0x3f
    /// ];
    /// 
    /// let mut writer = BytesMut::new();
    /// let extension = Extension {
    ///     data: &[0xaa, 0x36, 0x3f],
    ///     kind: 2,
    /// };
    /// 
    /// extension.into(&mut writer);
    /// assert_eq!(&writer[..], &buffer[..]);
    /// ```
    pub fn caller<Q, S, T>(&self, caller: T) -> RpcCaller<Q, S>
    where T: Caller<Q, S> + Send + Sync + 'static
    {
        RpcCaller::new(
            &caller.topic(), 
            self.0.clone(), 
            Box::new(caller)
        )
    }
}
